{"version":3,"file":"legendUtil.js","sources":["legendUtil.js"],"names":["define","array","lang","has","topic","domConst","domClass","domStyle","html","registry","gfx","esriRequest","Legend","esriBundle","i18n","widgets","legend","NLS_noLegend","noLegend","isLegend","controlOptions","controller","_legendRequest","layer","expandNode","callback","errback","url","callbackParamName","content","f","token","_getToken","then","hitch","this","_arcgisLegendRequest","index","toLowerCase","indexOf","soap","substring","length","window","escape","_image","layerId","src","imageData","img","create","class","id","set","width","height","opacity","layerLegend","map","getMap","layerInfos","setTimeout","startup","dynamicSublayerLegend","version","_createDynamicSublayerLegend","r","forEach","layers","_layer","table","add","row","symbol","innerHTML","label","place","sublayerExpandNode","byId","_dynamicSublayerLegendError","e","publish","source","error","_surfaceDims","vectorLegend","renderer","infos","_createVectorLegend","description","value","info","sym","descriptor","getShapeDescriptors","ds","defaultShape","fill","stroke","w","h","surfaceNode","display","surface","createSurface","shape","createShape","setFill","setStroke","applyTransform","dx","dy"],"mappings":"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","sourcesContent":["define([\n    'dojo/_base/array',\n    'dojo/_base/lang',\n    'dojo/has',\n    'dojo/topic',\n    'dojo/dom-construct',\n    'dojo/dom-class',\n    'dojo/dom-style',\n    'dojo/html',\n    'dijit/registry',\n    'dojox/gfx',\n    'esri/request',\n    // temp\n    'esri/dijit/Legend',\n    'dojo/i18n!esri/nls/jsapi',\n    'dojo/i18n!./../nls/resource'\n], function (\n    array,\n    lang,\n    has,\n    topic,\n    domConst,\n    domClass,\n    domStyle,\n    html,\n    registry,\n    gfx,\n    esriRequest,\n    Legend,\n    esriBundle,\n    i18n\n) {\n    'use strict';\n    esriBundle.widgets.legend.NLS_noLegend = i18n.noLegend;\n    return {\n        /////////////////////\n        // utility methods //\n        /////////////////////\n        // check controlOptions and controller to determine legend/no legend\n        // aliases e.g. controlOptions.noLegend\n        isLegend: function (controlOptions, controller) {\n            if (controller === null || controller === false) {\n                if (controlOptions === true) {\n                    return false;\n                } else {\n                    return true;\n                }\n            } else if (controller === true) {\n                if (controlOptions === false) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        },\n        // request legend json\n        _legendRequest: function (layer, expandNode, callback, errback) {\n            esriRequest({\n                url: layer.url + '/legend',\n                callbackParamName: 'callback',\n                content: {\n                    f: 'json',\n                    token: (typeof layer._getToken === 'function') ? layer._getToken() : null\n                }\n            }).then(\n                lang.hitch(this, callback, layer, expandNode),\n                lang.hitch(this, errback, layer, expandNode)\n            );\n        },\n        // request arcgis.com legend json\n        _arcgisLegendRequest: function (layer, expandNode, callback, errback) {\n            var index = layer.url.toLowerCase().indexOf('/rest/');\n            var soap = layer.url.substring(0, index) + layer.url.substring(index + 5, layer.url.length);\n            var url = 'http://utility.arcgis.com/sharing/tools/legend?soapUrl=' + window.escape(soap);\n            if (!has('ie') || has('ie') > 8) {\n                url += '&returnbytes=true';\n            }\n            esriRequest({\n                url: url,\n                callbackParamName: 'callback',\n                content: {\n                    f: 'json'\n                }\n            }).then(\n                lang.hitch(this, callback, layer, expandNode),\n                lang.hitch(this, errback, layer, expandNode)\n            );\n        },\n        // create a legend image from json\n        _image: function (legend, layerId, layer) {\n            var src = legend.url;\n            if ((!has('ie') || has('ie') >= 9) && legend.imageData && legend.imageData.length > 0) {\n                src = 'data:image/png;base64,' + legend.imageData;\n            } else if (legend.url.indexOf('http') !== 0) {\n                src = layer.url + '/' + layerId + '/images/' + legend.url;\n                var token = layer._getToken();\n                if (token) {\n                    src += '?token=' + token;\n                }\n            }\n            // create image\n            var img = domConst.create('img', {\n                src: src,\n                'class': layer.id + '-layerLegendImage'\n            });\n            domStyle.set(img, {\n                'width': legend.width + 'px',\n                'height': legend.height + 'px',\n                'opacity': layer.opacity\n            });\n            return img;\n        },\n        ////////////////////////////////////////\n        // layer legend for dynamic and tiled //\n        ////////////////////////////////////////\n        // image layers will most likely have own legend methods...but use this for now\n        layerLegend: function (layer, expandNode) {\n            // a stop gap\n            var legend = new Legend({\n                map: layer.getMap(),\n                layerInfos: [{\n                    layer: layer\n                }]\n            }, domConst.create('div', {}, expandNode));\n            // strange dijit/Popup error if startup() immediately...weird\n            setTimeout(function () {\n                legend.startup();\n            }, 1);\n            // check version and handle accordingly\n            //if (layer.version >= 10.01) {\n            //    this._legendRequest(layer, expandNode, '_createLayerLegend', '_layerLegendError');\n            //} else {\n            //    this._arcgisLegendRequest(layer, expandNode, '_createLayerLegend', '_layerLegendError');\n            //}\n        },\n        /////////////////////////////\n        // dynamic sublayer legend //\n        /////////////////////////////\n        // create legends for dynamic control w/ sublayers\n        dynamicSublayerLegend: function (layer, expandNode) {\n            // check version and handle accordingly\n            if (layer.version >= 10.01) {\n                this._legendRequest(layer, expandNode, '_createDynamicSublayerLegend', '_dynamicSublayerLegendError');\n            } else {\n                this._arcgisLegendRequest(layer, expandNode, '_createDynamicSublayerLegend', '_dynamicSublayerLegendError');\n            }\n        },\n        // handle the response, build legends and place\n        // TODO: is there a better way than using registry to place sublayer legends?\n        //       could remove id's from sublayer controls and simplify some\n        //       is query a better option or not?\n        _createDynamicSublayerLegend: function (layer, expandNode, r) {\n            array.forEach(r.layers, function (_layer) {\n                var layerId = _layer.layerId;\n                // create legend table\n                var table = domConst.create('table');\n                domClass.add(table, 'layerControlLegendTable');\n                // iterate through legends\n                array.forEach(_layer.legend, function (legend) {\n                    // create a table row and symbol td\n                    var row = domConst.create('tr', {}, table, 'last'),\n                        symbol = domConst.create('td', {\n                            'class': 'layerControlLegendImage'\n                        }, row, 'first');\n                    // create label td\n                    domConst.create('td', {\n                        innerHTML: legend.label || '&nbsp;',\n                        'class': 'layerControlLegendLabel'\n                    }, row, 'last');\n\n                    domConst.place(this._image(legend, layerId, layer), symbol);\n                }, this);\n                // place legend in the appropriate sublayer expandNode\n                // or if a single layer use control expandNode\n                if (layer.layerInfos.length > 1) {\n                    var sublayerExpandNode = registry.byId(layer.id + '-' + _layer.layerId + '-sublayer-control').expandNode;\n                    html.set(sublayerExpandNode, ''); //clear \"No Legend\" placeholder\n                    domConst.place(table, sublayerExpandNode);\n                } else {\n                    domConst.place(table, expandNode);\n                }\n            }, this);\n        },\n        // handle error\n        _dynamicSublayerLegendError: function (layer, expandNode, e) {\n            if (layer.layerInfos.length === 1) {\n                html.set(expandNode, 'No Legend');\n            }\n            topic.publish('viewer/handleError', {\n                source: 'LayerControl/legendUtil/_createDynamicSublayerLegend',\n                error: e\n            });\n        },\n        /////////////////////////\n        // vector layer legend //\n        /////////////////////////\n        // width and height of surface\n        _surfaceDims: [20, 20],\n        // determine what the renderer is and handle appropriately\n        vectorLegend: function (layer, expandNode) {\n            //  layer.renderer.symbol = single symbol (esri.renderer.SimpleRenderer, etc)\n            //  layer.renderer.infos = multiple symbols (esri.renderer.UniqueValueRenderer, etc)\n            //  TODO: read up on every single renderer! (just to be a better person)\n            var symbol = layer.renderer.symbol,\n                infos = layer.renderer.infos;\n            // are we dealing w/ a single symbol, multiple symbols or nothing\n            if (symbol) {\n                // pass array with single object equivalent to an `infos` object\n                this._createVectorLegend([{\n                    symbol: symbol,\n                    description: '',\n                    label: '',\n                    value: ''\n                }], layer, expandNode);\n            } else if (infos) {\n                this._createVectorLegend(infos, layer, expandNode);\n            } else {\n                html.set(expandNode, 'No Legend');\n            }\n        },\n        // create legends for vector layers (feature, etc)\n        _createVectorLegend: function (infos, layer, expandNode) {\n            //create legend table\n            var table = domConst.create('table');\n            domClass.add(table, 'layerControlLegendTable');\n            //iterate over infos\n            array.forEach(infos, function (info) {\n                //create a table row and symbol\n                var row = domConst.create('tr', {}, table, 'last'),\n                    symbol = domConst.create('td', {\n                        'class': 'layerControlLegendImage'\n                    }, row, 'first');\n                domConst.create('td', {\n                    innerHTML: info.label || '&nbsp;',\n                    'class': 'layerControlLegendLabel'\n                }, row, 'last');\n                // the symbol and descriptors\n                var sym = info.symbol,\n                    descriptor = sym.getShapeDescriptors(),\n                    ds = descriptor.defaultShape,\n                    fill = descriptor.fill,\n                    stroke = descriptor.stroke;\n                // it's either an image or we're creating a gfx shape representation of the symbol\n                if (!ds.src) {\n                    if (sym) {\n                        // width and height\n                        var w = this._surfaceDims[0],\n                            h = this._surfaceDims[1];\n                        if (sym.width && sym.height) {\n                            w = sym.width;\n                            h = sym.height;\n                        }\n                        // create node for surface\n                        var surfaceNode = domConst.create('span', {}, symbol);\n                        domStyle.set(surfaceNode, {\n                            'width': w + 'px',\n                            'height': h + 'px',\n                            'display': 'inline-block'\n                        });\n                        // create surface and add shape\n                        var surface = gfx.createSurface(surfaceNode, w, h);\n                        var shape = surface.createShape(ds);\n                        if (fill) {\n                            shape.setFill(fill);\n                        }\n                        if (stroke) {\n                            shape.setStroke(stroke);\n                        }\n                        shape.applyTransform({\n                            dx: w / 2,\n                            dy: h / 2\n                        });\n                        // set opacity of td\n                        //  it works but is there a better way?\n                        domStyle.set(symbol, {\n                            'opacity': layer.opacity\n                        });\n                        domClass.add(symbol, layer.id + '-layerLegendImage');\n                    } else {\n                        html.set(expandNode, 'No Legend');\n                        topic.publish('viewer/handleError', {\n                            source: 'LayerControl/legendUtil/_createVectorLegend',\n                            error: 'renderer does not contain symbol(s)'\n                        });\n                    }\n                } else {\n                    // create image\n                    var img = domConst.create('img', {\n                        src: ds.src\n                    }, symbol);\n                    domStyle.set(img, {\n                        'width': sym.width + 'px',\n                        'height': sym.height + 'px',\n                        'opacity': layer.opacity\n                    });\n                    domClass.add(img, layer.id + '-layerLegendImage');\n                }\n                // place legend in expandNode\n                domConst.place(table, expandNode);\n            }, this);\n        }\n    };\n});"]}